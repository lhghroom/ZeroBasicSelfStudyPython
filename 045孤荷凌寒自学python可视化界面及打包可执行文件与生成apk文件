孤荷凌寒自学python第四十五天Python初学基础基本结束的下阶段预安装准备

（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）
今天本来应当继续学习Python的数据库操作，但根据过去我自学其它编程语言的经验，我觉得对Python的肤浅的基础的知识学习完成之后，一定也要开始的构建自己的Python编程大厦的脚手架——开始将一些自己用起来顺手的常用功能封装块化，建立模块和类，形成一种基础沉淀，这样整个自己的Python学习大厦才将越修越好，这是从我过往的编程语言自学中总结出来的，当然还不知道是否也适用于Python.
不过我仍然决定对Python后续可能必须用到的一些模块和知识进行了解，并预安装相关的，以便在搭建自己的通用的模块和类时，能够有针对 性的向实用的方向进行建构。
于是今天发现了Python必须面对的可视化界面的相关组件，于是进行了安装相应模块和简单的测试，且分别在windows下和linux下两种系统进行了屡败屡战的尝试，最终勉强成功。
一、	在windows10下对可视化界面相关组件的安装
python 自带的基础的可视化界面的标准库模块tkinter，足够一般性的应用，因此目前不打算专门安装其它扩展性更好的可视化界面库。但tkinter有一个先天不足，要描述一个窗体界面上的控件（如按钮和输入框等）时，必须只能通过代码来指定每个控件的属性（如大小，位置等等）。这其实非常花费时间，并不是可见即可得，于是为了效率，人们想出了很多方法来让tkinter的可视化界面设计也可能直接【画出】控件来，方法各种各样，但我选择了了安装page-python来实现，因为此程序在windows和linux下都可以使用。
1．	tcl/tk
在安装page-python之前首先应当安装tcl组件和tk组件，否则page-python安装后也无法运行。
（1）	首先找到windows版本的tcl/tk组件的下载网站：
https://www.activestate.com/activetcl/downloads
选择适合当前操作系统的文件版本，注意是32位还是64位且是windows版本的安装包才行。
（2）	下载后是一个EXE文件，直接安装即可。
2．	page-python
（1）到下边的网站去下载page-python
https://sourceforge.net/projects/page/
此网站打开后，自动判断你的操作系统，然后在界面上只出现唯一的一个下载地址，直接点击下载即可。
（2）下载完成后，也是一个exe文件，直接安装即可。
（3）	安装完成后，桌面上会有Page的图标，打开就可以直接在上面设置窗体并在窗体上画上各种控件并设置每个控件的属性。
（4）	也可以代码编辑每个控件触发时要执行的操作，整个操作就非常方便了。
（5）	具体使用没有深入研究，但进行了简单的测试，通过Page-python软件得到的python文件源代码如下：

#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 4.16
# In conjunction with Tcl version 8.6
#    Aug 31, 2018 05:56:26 PM CST  platform: Windows NT

import sys

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = Tk()
    top = __________ (root)
    init(root, top)
    root.mainloop()

w = None
def create___________(root, *args, **kwargs):
    '''Starting point when module is imported by another program.'''
    global w, w_win, rt
    rt = root
    w = Toplevel (root)
    top = __________ (w)
    init(w, top, *args, **kwargs)
    return (w, top)

def destroy___________():
    global w
    w.destroy()
    w = None

class __________:
    def __init__(self, top=None):
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9' # X11 color: 'gray85'
        _ana1color = '#d9d9d9' # X11 color: 'gray85' 
        _ana2color = '#d9d9d9' # X11 color: 'gray85' 
        font9 = "-family {Microsoft YaHei UI} -size 16 -weight normal "  \
            "-slant roman -underline 0 -overstrike 0"

        top.geometry("1234x818+1499+413")
        top.title("孤荷凌寒的第一个界面")
        top.configure(background="#d9d9d9")


        self.txtMain = Text(top)
        self.txtMain.place(relx=0.1, rely=0.01, relheight=0.24, relwidth=0.81)
        self.txtMain.configure(background="white")
        self.txtMain.configure(font="TkTextFont")
        self.txtMain.configure(foreground="black")
        self.txtMain.configure(highlightbackground="#d9d9d9")
        self.txtMain.configure(highlightcolor="black")
        self.txtMain.configure(insertbackground="black")
        self.txtMain.configure(selectbackground="#c4c4c4")
        self.txtMain.configure(selectforeground="black")
        self.txtMain.configure(width=1004)
        self.txtMain.configure(wrap=WORD)

        self.bntMain = Button(top,command=onBtnMainClick)
        self.bntMain.place(relx=0.38, rely=0.4, height=106, width=343)
        self.bntMain.configure(activebackground="#d9d9d9")
        self.bntMain.configure(activeforeground="#000000")
        self.bntMain.configure(background="#18cbd8")
        self.bntMain.configure(disabledforeground="#a3a3a3")
        self.bntMain.configure(font=font9)
        self.bntMain.configure(foreground="#840da8")
        self.bntMain.configure(highlightbackground="#d9d9d9")
        self.bntMain.configure(highlightcolor="black")
        self.bntMain.configure(pady="0")
        self.bntMain.configure(text='''确定''')
        self.bntMain.configure(width=343)
        #self.bntMain.configure(command=onBtnMainClick)
        

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None
    
def onBtnMainClick():
    
    w.txtMain.insert('1.0','hello\n')

if __name__ == '__main__':
    
    vp_start_gui()
运行结果会弹出一个windows窗口，点击按钮可以执行代码指定的操作。具体过程请参看我学习过程中的屏幕录像。

二、	在Fedora系统下对可视化界面相关组件的安装
在我的fedora系统中，python中自带的的tkinter居然没有安装！
于是又费了些周折才安装起：
[pw@localhost ~]$ yum -y install tkinter
错误：该命令必须以 root 用户运行
[pw@localhost ~]$ sudo su
[sudo] pw 的密码：
[root@localhost pw]# yum -y install tkinter
上次元数据过期检查：0:07:30 前，执行于 2018年09月08日 星期六 10时24分32秒。
依赖关系解决。
=======================
 软件包                架构         版本                    仓库           大小
==========================
安装:
 python2-tkinter       x86_64       2.7.15-2.fc28           updates       400 k
正在安装安装依赖关系:
 tix                   x86_64       1:8.4.3-21.fc28         fedora        261 k

事务概要
======================
安装  2 软件包

总下载：662 k
安装大小：2.6 M
下载软件包：
(1/2): python2-tkinter-2.7.15-2.fc28.x86_64.rpm 1.1 MB/s | 400 kB     00:00    
(2/2): tix-8.4.3-21.fc28.x86_64.rpm             676 kB/s | 261 kB     00:00    
-----------------------
总计                                             25 kB/s | 662 kB     00:26     
运行事务检查
事务检查成功。
运行事务测试
事务测试成功。
运行事务
  准备中  :                                                                 1/1 
  安装    : tix-1:8.4.3-21.fc28.x86_64                                      1/2 
  运行脚本: tix-1:8.4.3-21.fc28.x86_64                                      1/2 
  安装    : python2-tkinter-2.7.15-2.fc28.x86_64                            2/2 
  运行脚本: python2-tkinter-2.7.15-2.fc28.x86_64                            2/2 
  验证    : python2-tkinter-2.7.15-2.fc28.x86_64                            1/2 
  验证    : tix-1:8.4.3-21.fc28.x86_64                                      2/2 

已安装:
  python2-tkinter.x86_64 2.7.15-2.fc28        tix.x86_64 1:8.4.3-21.fc28       

完毕！
[root@localhost pw]# yum install python3-tkinter
上次元数据过期检查：0:08:29 前，执行于 2018年09月08日 星期六 10时24分32秒。
依赖关系解决。
===============
 软件包                 架构          版本                 仓库            大小
================
安装:
 python3-tkinter        x86_64        3.6.6-1.fc28         updates        370 k

事务概要
=====================
安装  1 软件包

总下载：370 k
安装大小：1.5 M
确定吗？[y/N]：y
下载软件包：
python3-tkinter-3.6.6-1.fc28.x86_64.rpm         1.1 MB/s | 370 kB     00:00    
-------------
总计                                            297 kB/s | 370 kB     00:01     
运行事务检查
事务检查成功。
运行事务测试
事务测试成功。
运行事务
  准备中  :                                                                 1/1 
  安装    : python3-tkinter-3.6.6-1.fc28.x86_64                             1/1 
  运行脚本: python3-tkinter-3.6.6-1.fc28.x86_64                             1/1 
  验证    : python3-tkinter-3.6.6-1.fc28.x86_64                             1/1 

已安装:
  python3-tkinter.x86_64 3.6.6-1.fc28           
1．	tcl/tk
在安装page-python之前首先应当安装tcl组件和tk组件，否则page-python安装后也无法运行。
（1）	首先找到linux版本的tcl/tk组件的下载网站：
https://www.activestate.com/activetcl/downloads
选择适合当前操作系统的文件版本，注意是32位还是64位且是linux版本的压缩包才行。
（2）	下载后的文件如下命名的文件：
ActiveTcl.tar.gz
可以使用命令行解压这个文件，我是直接鼠标右键提取的这个文件到下载目录。
命令行解压是这样的：
cd 下载的文件所在目录
tar zxvf ActiveTcl.tar.gz
解压后得到的文件夹的名称是：
ActiveTcl
（3）现在通过命令行的cp命令将这个文件夹复制到主目录的/usr/share/目录下
命令行如下：
cp -a /home/pw/ActiveTcl /usr/share
注意复制命令的参数-a必须要有，我一开始就遗忘了，上网搜索才弄对，因此在Linux系统下对Linux的命令行一定要非常熟悉。
（4）此时通过cd命令进入复制到的目标文件夹：
cd /usr/share/ActiveTcl
(5)这个时候就可以直接执行ActiveTcl文件中的install.sh文件安装即可
命令行如下：
./install.sh
然而，我的fedora系统在这儿却失败了，提示缺少依赖项：
libXss.so.1
于是我执行安装命令安装libXss.so.1
命令行如下：
yum install libXss.so.1
这个顺利安装成功，但当再次执行ActiveTcl文件中的install.sh文件安装时，还是提示没有libXss.so.1组件，顿时懵了，明明安装成功了啊！
又花了一个小时才终于明白，原来我的fedora系统是64位的，而yum install libXss.so.1 命令默认只会安装32位的，不得不让我发出悲叹这是多么坑爹的设计啊！这Linux系统果然是明不虚传的难弄！
于是下载了64位的libXss.so.1进行安装：
下载地址：
https://pkgs.org/download/libXss.so.1
注意选择正确的Linux系统版本与32位或64位的文件下载
我下载的文件名：
libXScrnSaver-1.2.2-14.fc28.x86_64.rpm
注意文件名中的FC28指的是对应的fedora系统版本fedora28版。
rpm文件可以在fedora系统中右键直接点击安装。
当然也可以通过命令行，直接下载和安装：
直接自动下载并安装64位的命令行如下：
sudo dnf install /usr/lib64/libXss.so.1
然后再次执行下面的命令就成功了：
./install.sh
但是此时命令行会有很多英文提示输入安装的目录和工作文件夹等，我英文不是很好，费不尽的力才终于设置好，最终得到的结论是保持它默认设置的的目录就行了。这个我的操作看下我操作过程中的屏幕录像。
2．	page-python
（1）到下边的网站去下载page-python
https://sourceforge.net/projects/page/
此网站打开后，自动判断你的操作系统，然后在界面上只出现唯一的一个下载地址，直接点击下载即可。
（2）此时下载下来的是一个压缩包，如下文件命名的压缩包：
page-4.16.tgz
在Fedora系统中可以直接鼠标右键解压它。
（3）然后通过cp命令复制到需要的目录下
cp -a /home/pw/page-4.16 /usr/share/Visual/
（4）接下来通过cd命令进入page-4.16目录中
cd /usr/share/Visual/page-4.16
（5）这时候要手动打开/usr/share/Visual/page-4.16目录下的文件：
page.tcl
把文件中的第一行修改为以下的内容：
#! /usr/bin/env tclsh
其实修改的就是最后的tclsh这五个字母
为了解决这个问题，当时反复上网搜索，结果网上讲的都并不适用于我的操作系统，花了数个小时，最后才自己独立思考得出它原文件中的第一行根本没有提到tcl这个组件，于是我就尝试将其修改为了tclsh，没想到就成功了。
（6）修改完成后，再输入以下命令：
tclsh page.tcl
这样，与windows系统中一模一样的page界面就出现了，但是不知道是不是我的fedora系统显示的原因，整个page编辑的界面上的文字非常的小，基本看不到文字，当然我是将屏幕显示分辨率提高到300%，加上是4K显示器，不知道是不是这个原因，具体情况看我操作过程的屏幕录像。因此实际上这个Page软件界面对我的系统而言无法操作，除非我还得配上放大镜。
但是最终是安装成功的。
3．同样在fedora系统下测试了上面在windows系统下测试过的可视化界面的Py文件，发现运行效果是完全一样的。

三、	在windows系统下安装相关组件以便将Py文件打包成exe文件
1.安装pyinstaller组件
通过以下命令安装pyinstaller组件
pip install pyinstaller
如果安装过程中报错，主要是32位windows系统报错的话，可能要先安装下面的组件，命令行如下：
pip install pywin32
2.安装完成后，此操作在windows下就大功造成了，关于pyintaller的使用目前并没有研究，只知道它既可以将单个Py文件打包成一个exe文件，也可以将一个文件夹的Py程序汇总打包成exe文件，而且要得到exe文件此操作必须在windows环境下运行才行。

四、	在Linux系统下安装相关组件以便将Py文件打包成Linux系统下的可执行文件
1. .安装pyinstaller组件
通过以下命令安装pyinstaller组件
pip install pyinstaller
但如果fedora系统中有两个Python版本，此命令默认安装的是：Python2.7对应的pyinstaller，如果要安装python3.6对应的版本，则应当使用以下命令：
pip3 install pyinstaller
2.此组件安装完成后，就可以使用此组件将一个或多个Py文件直接打包为在Linux下可以执行的执行文件了，此类执行文件是没有后缀名的。且只能在Linux系统下运行。

五、	尝试将Py文件打包为可执行文件
1.就使用刚才测试过的用tkinter库设计编写的有可视化编程界面的的Py文件（此文件的可视化界面是在windows下用page-python手动画控件设置的）在windows10环境下打包成windows的可执行程序exe文件。
此py文件名为：
unknown.py
在windows的命令行窗口中输入以下命令：
pyinstaller -Fw I:\MAKEAPP\python\Python365\边学习边测试文件夹\自学PYTHON部分\unknown.py --distpath=E:/dist
注意参数 –Fw 是必须 的，这样才能保证打开exe文件时，程序直接出现程序窗口界面，就再不会先出现命令行窗口了。
打包完成后，就会在参数中指明的“E:/dist”文件夹下出现一个exe文件，名为：
unknown.exe
然后我在打包所用的windows10系统环境下进行了测试，此系统中安装有python3.6.5，可以轻松打开并正确执行。
接下来在没有安装Python的其它windows10系统中进行测试，也可以完美运行。、但在windows10之外的其它操作系统上就不能运行了（如windows7和windows8都不行）。
而且因为我打包用的windows10系统是64位的，打包出来的exe文件也就是64位的exe程序，因此不能在32位windows10系统上运行。
2.就使用与windows10下打包相同的同一个Py文件在fedora28系统环境下打包成linux系统的可执行程序文件（这种执行文件没有可区别的后缀名）。
此py文件名为：
unknown.py
打开fedora操作系统的命令行终端，输入以下命令：
pyinstaller -Fw /home/pw/unknown.py --distpath=/home/pw/dist
注意参数 –Fw 是必须 的，这样才能保证打开打包得到的linux下可执行的程序文件时，程序直接出现程序窗口界面，就再不会先出现命令行窗口了。
打包完成后，就会在命令行中指明的目录“/home/pw/dist”中得到一个在Linux下可执行的程序 文件：
unknown
我的fedora28系统是64位的，但也没有安装32位的Linux系统可以测试。
在当前打包时用到的fedora28系统中可以轻松完美的运行这个程序文件。
然后就开始到其它linux系统中去测试：
在安装有python3.5.6的fedora28,64位系统中，测试结果为：可以正常打开程序并执行所有功能。
在centos7, 64位系统中，也没有安装任何 python3.6.6，测试结果为:不能正常打开任何程序。

今天只对pyinstaller的基本功能进行了一下测试，且只打包了有可视界面的单一一个Py文件而已，今后在实际学习到的时候，还将使用它来打包整个python程序工程目录,其它功能将在实际需要的时候再学习。

六、	安装可以将Py文件打包为Android系统可执行的apk程序文件的相关组件
python的神奇之处在于它的Py文件也可以被打包成apk文件，然后就可以在android系统中运行了。
当然今天只是对需要的打包环境组件进行了安装，且打包的实际操作只能在linux系统下进行，于是重点就在我的fedora28系统中进行。
核心的教程来自于：
https://kivy.org/#download
其中包含了所有操作系统的教程，不过是英文的。
整个过程非常艰辛，现记录安装过程的具体流程如下：
1.升级yum安装包
yum -y upgrade

2.安装依赖项组件
sudo yum install \
    make \
    mercurial \
    automake \
    gcc \
    gcc-c++ \
    SDL_ttf-devel \
    SDL_mixer-devel \
    khrplatform-devel \
    mesa-libGLES \
    mesa-libGLES-devel \
    gstreamer-plugins-good \
    gstreamer \
    gstreamer-python \
    mtdev-devel \
    python-devel \
    python-pip
这些所有依赖项组件安装都比较顺利，只有其中的：
khrplatform-devel
不管怎样升级扩充yum源包都无法安装它，但最后没有安装它也还是没有发生任何错误。

3.升级更新两个安装组件
sudo pip install --upgrade pip virtualenv setuptools

4 .安装kivy解释器
virtualenv --no-site-packages kivyinstall

5.激活解释器
. kivyinstall/bin/activate

6.安装python的numpy组件
pip3 install numpy

7.安装cython
pip3 install Cython

8.安装pygame
pip3 install hg+http://bitbucket.org/pygame/pygame

9.安装kivy（如果要安装下一步的开发版本就不要安装这一个）
pip3 install kivy

10.实际上我安装的是开发版本(如果已安装上一个就不要安装这一个)
pip3 install git+https://github.com/kivy/kivy.git@master

11.安装kivy周边组件包
pip3 install git+https://github.com/kivy/buildozer.git@master
pip3 install git+https://github.com/kivy/plyer.git@master
pip3 install -U pygments docutils

12.安装buildozer 生成器（我fedora28系统中已自带，所以没有安装，下面是网络上的从源安装最新版的方法）
（1）下载包：
git clone https://github.com/kivy/buildozer.git
（2）cd 到下载的包（解压 后的包所在目录）
（3）执行包根目录下的安装文件
sudo python3.6 setup.py install
当然也可以直接尝试用Pip安装（可能失败，而且可能没有安装到最新版本）
pip3 install buildozer

13.安装javac
sudo dnf install java*jdk*devel*

到此在Fedora28下的所有安装都已完成

七、实际测试下，将一个用Kivy写的有可视界面的Py程序打包成apk文件
关于打包apk的详细教程在以下网站：
https://pypi.org/project/buildozer/
1.复制了网络上的一个测试py文件，我命名为main.py
程序代码如下：
import kivy
kivy.require('1.11.0')


from math import floor
from kivy.app import App
from kivy.properties import NumericProperty
from kivy.clock import Clock
from kivy.vector import Vector
from kivy.animation import Animation
from kivy.lang import Builder
import pygame
import kivy.lib.vidcore_lite



kv = Builder.load_string('''
Button:
    text: "I am a button."
''')

class TestApp(App):
    def build(self):
        return kv

TestApp().run()

此main.py文件存放在/home/pw/a目录下。

2.然后在fedora的命令行终端中输入：

[pw@localhost ~]$ cd /home/pw/a
[pw@localhost ~]$ buildozer init
执行此命令后，将在a目录下得到一个配置文件：
buildozer.spec
此文件中设置了生成的各种参数：
[app]

# (str) Title of your application
title = My Application

# (str) Package name
package.name = myapp

# (str) Package domain (needed for android/ios packaging)
package.domain = org.test

# (str) Source code where the main.py live
source.dir = .

# (list) Source files to include (let empty to include all the files)
source.include_exts = py,png,jpg,kv,atlas

# (list) List of inclusions using pattern matching
#source.include_patterns = assets/*,images/*.png

# (list) Source files to exclude (let empty to not exclude anything)
#source.exclude_exts = spec

# (list) List of directory to exclude (let empty to not exclude anything)
#source.exclude_dirs = tests, bin

# (list) List of exclusions using pattern matching
#source.exclude_patterns = license,images/*/*.jpg

# (str) Application versioning (method 1)
version = 0.1

# (str) Application versioning (method 2)
# version.regex = __version__ = ['"](.*)['"]
# version.filename = %(source.dir)s/main.py

# (list) Application requirements
# comma seperated e.g. requirements = sqlite3,kivy
requirements = kivy

# (str) Custom source folders for requirements
# Sets custom source for any requirements with recipes
# requirements.source.kivy = ../../kivy

# (list) Garden requirements
#garden_requirements =

# (str) Presplash of the application
#presplash.filename = %(source.dir)s/data/presplash.png

# (str) Icon of the application
#icon.filename = %(source.dir)s/data/icon.png

# (str) Supported orientation (one of landscape, portrait or all)
orientation = portrait

# (list) List of service to declare
#services = NAME:ENTRYPOINT_TO_PY,NAME2:ENTRYPOINT2_TO_PY

#
# OSX Specific
#

#
# author = © Copyright Info

# change the major version of python used by the app
osx.python_version = 3

# Kivy version to use
osx.kivy_version = 1.11.0

#
# Android specific
#

# (bool) Indicate if the application should be fullscreen or not
fullscreen = 0

# (string) Presplash background color (for new android toolchain)
# Supported formats are: #RRGGBB #AARRGGBB or one of the following names:
# red, blue, green, black, white, gray, cyan, magenta, yellow, lightgray,
# darkgray, grey, lightgrey, darkgrey, aqua, fuchsia, lime, maroon, navy,
# olive, purple, silver, teal.
#android.presplash_color = #FFFFFF

# (list) Permissions
#android.permissions = INTERNET

# (int) Android API to use
#android.api = 19

# (int) Minimum API required
#android.minapi = 9

# (int) Android SDK version to use
#android.sdk = 20

# (str) Android NDK version to use
#android.ndk = 9c

# (bool) Use --private data storage (True) or --dir public storage (False)
#android.private_storage = True

# (str) Android NDK directory (if empty, it will be automatically downloaded.)
#android.ndk_path =

# (str) Android SDK directory (if empty, it will be automatically downloaded.)
#android.sdk_path =

# (str) ANT directory (if empty, it will be automatically downloaded.)
#android.ant_path =

# (bool) If True, then skip trying to update the Android sdk
# This can be useful to avoid excess Internet downloads or save time
# when an update is due and you just want to test/build your package
# android.skip_update = False

# (str) Android entry point, default is ok for Kivy-based app
#android.entrypoint = org.renpy.android.PythonActivity

# (list) Pattern to whitelist for the whole project
#android.whitelist =

# (str) Path to a custom whitelist file
#android.whitelist_src =

# (str) Path to a custom blacklist file
#android.blacklist_src =

# (list) List of Java .jar files to add to the libs so that pyjnius can access
# their classes. Don't add jars that you do not need, since extra jars can slow
# down the build process. Allows wildcards matching, for example:
# OUYA-ODK/libs/*.jar
#android.add_jars = foo.jar,bar.jar,path/to/more/*.jar

# (list) List of Java files to add to the android project (can be java or a
# directory containing the files)
#android.add_src =

# (list) Android AAR archives to add (currently works only with sdl2_gradle
# bootstrap)
#android.add_aars =

# (list) Gradle dependencies to add (currently works only with sdl2_gradle
# bootstrap)
#android.gradle_dependencies =

# (list) Java classes to add as activities to the manifest.
#android.add_activites = com.example.ExampleActivity

# (str) python-for-android branch to use, defaults to stable
#p4a.branch = stable

# (str) OUYA Console category. Should be one of GAME or APP
# If you leave this blank, OUYA support will not be enabled
#android.ouya.category = GAME

# (str) Filename of OUYA Console icon. It must be a 732x412 png image.
#android.ouya.icon.filename = %(source.dir)s/data/ouya_icon.png

# (str) XML file to include as an intent filters in <activity> tag
#android.manifest.intent_filters =

# (str) launchMode to set for the main activity
#android.manifest.launch_mode = standard

# (list) Android additionnal libraries to copy into libs/armeabi
#android.add_libs_armeabi = libs/android/*.so
#android.add_libs_armeabi_v7a = libs/android-v7/*.so
#android.add_libs_x86 = libs/android-x86/*.so
#android.add_libs_mips = libs/android-mips/*.so

# (bool) Indicate whether the screen should stay on
# Don't forget to add the WAKE_LOCK permission if you set this to True
#android.wakelock = False

# (list) Android application meta-data to set (key=value format)
#android.meta_data =

# (list) Android library project to add (will be added in the
# project.properties automatically.)
#android.library_references =

# (str) Android logcat filters to use
#android.logcat_filters = *:S python:D

# (bool) Copy library instead of making a libpymodules.so
#android.copy_libs = 1

# (str) The Android arch to build for, choices: armeabi-v7a, arm64-v8a, x86
android.arch = armeabi-v7a

#
# Python for android (p4a) specific
#

# (str) python-for-android git clone directory (if empty, it will be automatically cloned from github)
#p4a.source_dir =

# (str) The directory in which python-for-android should look for your own build recipes (if any)
#p4a.local_recipes =

# (str) Filename to the hook for p4a
#p4a.hook =

# (str) Bootstrap to use for android builds
# p4a.bootstrap = sdl2

# (int) port number to specify an explicit --port= p4a argument (eg for bootstrap flask)
#p4a.port =


#
# iOS specific
#

# (str) Path to a custom kivy-ios folder
#ios.kivy_ios_dir = ../kivy-ios

# (str) Name of the certificate to use for signing the debug version
# Get a list of available identities: buildozer ios list_identities
#ios.codesign.debug = "iPhone Developer: <lastname> <firstname> (<hexstring>)"

# (str) Name of the certificate to use for signing the release version
#ios.codesign.release = %(ios.codesign.debug)s


[buildozer]

# (int) Log level (0 = error only, 1 = info, 2 = debug (with command output))
log_level = 1

# (int) Display warning if buildozer is run as root (0 = False, 1 = True)
warn_on_root = 1

# (str) Path to build artifact storage, absolute or relative to spec file
# build_dir = ./.buildozer

# (str) Path to build output (i.e. .apk, .ipa) storage
# bin_dir = ./bin

#    -----------------------------------------------------------------------------
#    List as sections
#
#    You can define all the "list" as [section:key].
#    Each line will be considered as a option to the list.
#    Let's take [app] / source.exclude_patterns.
#    Instead of doing:
#
#[app]
#source.exclude_patterns = license,data/audio/*.wav,data/images/original/*
#
#    This can be translated into:
#
#[app:source.exclude_patterns]
#license
#data/audio/*.wav
#data/images/original/*
#


#    -----------------------------------------------------------------------------
#    Profiles
#
#    You can extend section / key with a profile
#    For example, you want to deploy a demo version of your application without
#    HD content. You could first change the title to add "(demo)" in the name
#    and extend the excluded directories to remove the HD content.
#
#[app@demo]
#title = My Application (demo)
#
#[app:source.exclude_patterns@demo]
#images/hd/*
#
#    Then, invoke the command line with the "demo" profile:
#
#buildozer --profile demo android debug

这个文件中各个参数的含义没有具体了解，因此我只能保持默认状态。

3.然后执行生成操作
[pw@localhost a]$ buildozer android debug
# Check configuration tokens
# Ensure build layout
# Check configuration tokens
# Preparing build
# Check requirements for android
# Install platform
# Apache ANT found at /home/pw/.buildozer/android/platform/apache-ant-1.9.4
# Android SDK found at /home/pw/.buildozer/android/platform/android-sdk-20
# Android NDK found at /home/pw/.buildozer/android/platform/android-ndk-r9c

一般说来执行到这儿，因为这个时候要连接google的服务器下载android的很多文件来安装，因此，我试过连续让它运行十个小时，也无法再在此处有所进展。这网络速度是硬伤。最终没有等来apk文件的生成。

最后我在windows10下也成功安装了kivy 且功能使用正常，但无法安装执行 buildozer，因此要生成apk文件还是只能在linux下运行 buildozer才行。
就是要学  社群  www.941xue.com/index.aspx 
 原文地址：http://www.941xue.com/content.aspx?id=1390 
本笔记在B站上的视频地址：      https://www.bilibili.com/video/BV1Zt411v7uF/
Github:
https://github.com/lhghroom/ZeroBasicSelfStudyPython 

【欢迎大家加入[就是要学]社群】
如今，这个世界的变化与科技的发展就像一个机器猛兽，它跑得越来越快，跑得越来越快，在我们身后追赶着我们。
很多人很早就放弃了成长，也就放弃了继续奔跑，多数人保持终身不变的样子，原地不动，成为那猛兽的肚中餐——当然那也不错，在猛兽的逼迫下，机械的重复着自我感觉还良好地稳定工作与生活——而且多半感觉不到这有什么不正常的地方，因为在猛兽肚子里的是大多数人，就好像大多数人都在一个大坑里，也就感觉不出来这是一个大坑了，反而坑外的世界显得有些不大正常。
为什么我们不要做坑里的大多数人？
因为真正的人生，应当有百万种可能 ；因为真正的一生可以有好多辈子组成，每一辈子都可以做自己喜欢的事情；因为真正的人生，应当有无数种可以选择的权利，而不是总觉得自己别无选择。因为我们要成为一九法则中为数不多的那个一；因为我们要成为自己人生的导演而不是被迫成为别人安排的戏目中的演员。
【请注意】
就是要学社群并不会告诉你怎样一夜暴富！也不会告诉你怎样不经努力就实现梦想！
【请注意】
就是要学社群并没有任何可以应付未来一切变化的独门绝技，也没有值得吹嘘的所谓价值连城的成功学方法论！
【请注意】
社群只会互相帮助，让每个人都看清自己在哪儿，自己是怎样的，重新看见心中的梦想，唤醒各自内心中的那个英雄，然后勇往直前，成为自己想要成为的样子！
期待与你并肩奔赴未来！
www.941xue.com 
QQ群：646854445 （【就是要学】终身成长）
 


我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）
链接：https://pan.baidu.com/s/1VVs-bCKxBUJZzUaeMTq7HQ  
提取码：f84e 

Bilibili:
https://member.bilibili.com/v2#/upload-manager/article 

喜马拉雅语音笔记：
https://www.ximalaya.com/keji/19103006/146755924 

