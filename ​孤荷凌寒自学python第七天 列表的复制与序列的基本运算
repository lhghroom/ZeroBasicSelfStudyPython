一、建立一个列表的副本
1．如果使用直接赋值方式将一个列表直接赋值给另一个列表，那么，情况是这样的：
 
如：
>>> lstA=list('孤荷凌寒')
>>> print(lstA)
['孤', '荷', '凌', '寒']
>>> lstB=lstA  #直接将lstA赋值给lstB
>>> print(lstB)
['孤', '荷', '凌', '寒']   #现在发现lstB的内容与lstA完全一样
>>> print(lstA)
['孤', '荷', '凌', '寒']
>>> lstB.insert(0,'是')  #现在对lstB的内容进行修改
>>> print(lstB)
['是', '孤', '荷', '凌', '寒']  # lstB的内容在修改后改变了
>>> print(lstA)
['是', '孤', '荷', '凌', '寒']   #燃鹅，lstA的内容在lstB的内容修改后，居然也改变了
这说明这种方法直接赋值后，虽然得到了两个列表，却是两个完全“心灵相通”的列表，一个列表内容的改变，另一个列表内容也改变了。这种方法对于要想得到另一个完全独立的新列表的时候是不行的。
2．第二种方法，对列表分片（切片）后再赋值给新列表。
>>> lstA=list('孤荷凌寒')
>>> print(lstA)
['孤', '荷', '凌', '寒']
>>> lstB=lstA[:]  #先将lstA分片，分片代码：号的前后没有指明起止INDEX值，表示整个列表全部分作一片（即表示 整个列表）
>>> print(lstB)
['孤', '荷', '凌', '寒']   #现在发现lstB的内容仍然与lstA完全一样
>>> print(lstA)
['孤', '荷', '凌', '寒']
>>> lstB.insert(0,'是')  #现在对lstB的内容进行修改
>>> print(lstB)
['是', '孤', '荷', '凌', '寒']  # lstB的内容在修改后改变了
>>> print(lstA)
['孤', '荷', '凌', '寒']   #现在，lstA的内容在lstB的内容修改后，保持不变了，证明得到了一个完全独立的新列表，lstB,它和lstA已经没有任何关联了。
3．第三种方法，使用列表的copy方法可以取得和第2种方法一样的效果
>>> lstA=list('孤荷凌寒')
>>> print(lstA)
['孤', '荷', '凌', '寒']
>>> lstB=lstA.copy()   #现在让lstA执行copy()方法
>>> print(lstB)
['孤', '荷', '凌', '寒']   #现在发现lstB的内容仍然与lstA完全一样
>>> print(lstA)
['孤', '荷', '凌', '寒']
>>> lstB.insert(0,'是')  #现在对lstB的内容进行修改
>>> print(lstB)
['是', '孤', '荷', '凌', '寒']  # lstB的内容在修改后改变了
>>> print(lstA)
['孤', '荷', '凌', '寒']   #现在，lstA的内容在lstB的内容修改后，保持不变了，证明得到了一个完全独立的新列表，lstB,它和lstA已经没有任何关联了。
 
二、序列的基本运算
1． 序列相加
使用+运算符号将两个序列直接相加，运算结果是两个序列合并为一个序列，新序列的元素为原来两个序列的的元素的合并集合。
>>> strA='孤荷凌寒'
>>> strB='QQ号码578652607'
>>> lstA=list(strA)
>>> lstB=list(strB)
>>> strC=strA+strB
>>> print(strC)
孤荷凌寒QQ号码578652607
>>> lstC=lstA+lstB
>>> print(lstC)
['孤', '荷', '凌', '寒', 'Q', 'Q', '号', '码', '5', '7', '8', '6', '5', '2', '6', '0', '7']
2． 序列乘以一个整数自然数。
（1）      字符序列乘以一个整自然数n
是将序列中的每个字符元素进行n次重复，然后返回一个生成后的新的序列对象，原序列对象的内容没有改变。
>>> strA='孤荷凌寒'
>>> lstA=list(strA)
>>> strB=strA*2
>>> print(strB)
孤荷凌寒孤荷凌寒
>>> print(strA)
孤荷凌寒
>>> print(lstA)
['孤', '荷', '凌', '寒']
>>> lstB=lstA*2
>>> print(lstB)
['孤', '荷', '凌', '寒', '孤', '荷', '凌', '寒']
>>> print(lstA)
['孤', '荷', '凌', '寒']
（2）      只有一个元素的列表乘以一个整自然数n
将创建n个此元素重复的新列表。
>>> lstB=[7]
>>> lstC=lstB*10
>>> print(lstC)   
[7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
>>> print(lstB)
 [7]
（3）      非字符序列乘以一个整自然数n
我们大概会想象到，那一定是将序列每个元素都与这个整自然数相乘，然后返回由他们的积组成的新序列。
然而，事实不是这样的！！！感觉会上当的！！！
操作与字符串的序列操作没有区别
3． 我们也可以将一个数值型的序列与一个字符序列进行相+操作，得到一个混合多种数据类型元素的新序列
>>> lstA=list('孤荷凌寒的QQ号码是')
>>> lstB=[5,7,8,6,5,2,6,0,7]
>>> lstC=lstA+lstB
>>> print(lstC)
['孤', '荷', '凌', '寒', '的', 'Q', 'Q', '号', '码', '是', 5, 7, 8, 6, 5, 2, 6, 0, 7]
 
三、序列的in运算符
序列的in运算主要用于判断序列中是否存在指定对象值的元素
返回值：True   False
>>> strTemp='孤荷凌寒'
>>> isHad='荷' in strTemp
>>> print(isHad)
True
>>> lstTemp=list(strTemp)
>>> print(lstTemp)
['孤', '荷', '凌', '寒']
>>> isHad='凌' in lstTemp
>>> print(isHad)
True
四、用于序列的通用全局函数
1 len(obj)
Obj指一个序列对象。
返回字符串的字符总长度。
返回其它序列的元素总个数。
2 max(obj)和min(obj)
Obj指一个序列对象。
返回字符串中编码值最大和最小的那个字符
返回其它序列中（数值型序列）中值最大和最小的那个元素。
>>> strA='孤荷凌寒'
>>> strB=max(strA)
>>> print(strB)
荷
>>> lstTemp=[1,8,7,4]
>>> intA=max(lstTemp)
>>> print(intA)
8
 
 
欢迎联系我加入倡导终身学习终身成长的社群——
就是要学  社群  www.941xue.com/index.aspx
 
原文地址：http://www.941xue.com/content.aspx?id=141
 
B站视频：https://www.bilibili.com/video/BV1mt411m78g/
