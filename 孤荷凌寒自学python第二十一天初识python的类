类是面向对象的编程语言非常重要的概念。
编程语言的进化史中从顺序编程到结构化编程，最后才进化出面向对象的编程语言。今天主流的非常流行的编程语言如java等都是优秀的面向对象的编程语言。当然我感觉python也不例外，虽然目前我对python还没有深入了解。
类的概念是向现实世界借鉴了人们理解世界的常识而得出的：
人类认识世界都是分门别类进行的，比如，我们把整个所见的事物分为有生命的和无生命的两类。
在有生命的事物中，我们又分为微生物、植物、动物三大类。动物中我们又有了更多的分类。
而每一个类别不管它是个大的类别，还是小的类别，我们怎么区分开它们呢，那是因为每一类事物都有这一类事物的【特点】，这是我们识别每类事物的关键判断 点。
在编程语言中，一类事物的特点，即称为【类】的【属性】。
类除了有属性，每类事物还有它可以采取的行为，比如草履虫这种类别的动物就已经有“远离高盐溶液”这样的行为。
在编程语言中，一类事物可以执行的行为，即称为【类】的【方法】。
我个人呢是完全独自一人从零开始自学编程语言的，以上是自己对编程语言中【类】的基本理解，肯定不是很标准和精准，但可以基本描述出【类】的粗略特征。
我们已经知道了【类】的最重要的两个组成——【属性】与【方法】
定义一个类，最主要核心的就是要指明这个类的【属性】和【方法】

一、	类的定义格式
class 类名(基类列表) :
	类的代码块

类名，即是给类一个名称。
基类，又叫做父类。其实我认为理解为大类也可，其实就是我们生活中分类时更大的类。
	 举例说，狗类是一个大的类别，而狮子狗是狗类这个大类中的一个小类
	 而狮子狗不仅有一般狗类的特征（属性）也有自己这个小类别 的不同的特征
	 于是我们就说，狮子狗就来自于狗类这个基类的定义基础上的变化。
	 就把【狗类】称之为【狮子狗类】的【基类】也叫【父类】
基类列表，意味着一个类可能以多个不同上级类作为【基类】，同时具备多个【基类】的属性特征。

二、	类的属性
类的属性本质上是类内部代码块中定义的变量。
测试：
class 魔法水杯类(object): #object 是最基础的总类，python中的所有类都继承自object类
    颜色='红色'
    材质='魔法玻璃'
    透明度='半透明'
    容量='100毫升'
    #上面在类的内部代码中定义的四个全局变量：颜色、材质、透明度、容量 就是【魔法水杯类】的四个属性
要访问【类】中的属性，一般情况下需要将【类】实例化为具体的【对象】——
即是说，【魔法水杯类】还不是一个具体的东西，只是一类事物的总称，我们需要一个具体的【魔法水杯】才能具体访问其中的属性。

实例化【类】为具体的【对象】的方法是：
具体对象=类名([可选的初始化参数列表])
然后我们就可以通过：
具体对象.属性
	这样的形式来访问到【具体对象】的【属性】了。
测试：
class 魔法水杯类(object): #object 是最基础的总类，python中的所有类都继承自object类
    颜色='红色'
    材质='魔法玻璃'
    透明度='半透明'
    容量='100毫升'
    #上面在类的内部代码中定义的四个全局变量：颜色、材质、透明度、容量 就是【魔法水杯类】的四个属性

一只魔法水杯=魔法水杯类() #因为【魔法水杯类】没有定义初始化的形式参数，所以这儿在【实例化】类时，没有指定初始化实参。
print(一只魔法水杯.颜色) #现在可以通过 点 语法，在具体的对象 后访问 类 实例化 后的 具体对象的属性了。
print(一只魔法水杯.材质)
运行结果 ：
红色
魔法玻璃

三、	类的方法
类的方法即是说一个类可以执行的操作或可以执行的运算或可以完成的任务等。
现在要为上面测试定义的【魔法水杯类】添加可以执行的 方法，以便魔法水杯能有真正的“魔法操作”。
类的方法的实质 是 【类】的内部代码中定义的【函数】
一般情况下，我们仍然需要将【类】实例化为【具体对象】后才能通过点语法执行【具体对象】的方法。
测试：
class 魔法水杯类(object): #object 是最基础的总类，python中的所有类都继承自object类
    颜色='红色'
    材质='魔法玻璃'
    透明度='半透明'
    容量='100毫升'
    当前使用水杯的人='没有' #这是类中定义的一个全局变量
    #上面在类的内部代码块中定义的五个全局变量：颜色、材质、透明度、容量、当前使用水杯的人 就是【魔法水杯类】的五个属性

    def 告诉访问者魔法水杯的创造者(self): #这儿在类的内部代码块中定义了一个【函数】，对于类的外部访问者来说，这就是类的一个方法
        #类的内部代码块中定义的每个函数都有一个默认的【形参】—— self ,在类的外部具体访问类实例化后的对象的此方法时，却不要传递【实参】给这个【形参】。
        return '我的创造者是：孤荷凌寒'
    def 魔法水杯的容量最大值(self):
        return self.容量  #在类的内部代码块中的函数中访问类的属性时，在属性前面使用self表示类自身。
    def 告诉魔法水杯并返回目前使用魔法水杯的人(self,当前使用水杯的人='没有'): #此方法函数除了默认形参self之外，添加了一个可选形参——【使用水杯的人】，用于此方法函数接收并返回属性
        #此函数的形式参数【当前使用水杯的人】也可以认为是当前函数 的一个局部变量，注意此局部变量名与类的全局变量名完全相同
        if 当前使用水杯的人!='没有':
            strTemp=当前使用水杯的人 #此处的【当前使用水杯的人】，是函数的形式参数，也即是此函数的局部变量。
            self.当前使用水杯的人=strTemp #此处的【self.当前使用水杯的人】才是当前 类的 全局函数 ，也就是类的一个属性
        return self.当前使用水杯的人

一只魔法水杯=魔法水杯类() #因为【魔法水杯类】没有定义初始化的形式参数，所以这儿在【实例化】类时，没有指定初始化实参。
#print(一只魔法水杯.颜色) #现在可以通过 点 语法，在具体的对象 后访问 类 实例化 后的 具体对象的属性了。
#print(一只魔法水杯.材质)
str创造者=一只魔法水杯.告诉访问者魔法水杯的创造者() #这个类的这个方法函数不需要传递任何实参，因为此方法函数实际上除了self形参外没有定义其它形参。
str水杯的容量=一只魔法水杯.魔法水杯的容量最大值()
#下面第一次访问【一只魔法水杯】对象的【方法】：【告诉魔法水杯并返回目前使用魔法水杯的人】，要传递实参给此方法函数的形式参数——【当前使用水杯的人】
str水杯当前拥有者=一只魔法水杯.告诉魔法水杯并返回目前使用魔法水杯的人('张三')
print('str创造者=',str创造者)
print('str水杯的容量=',str水杯的容量)
print('str水杯当前拥有者=',str水杯当前拥有者)
#下面第二次访问【一只魔法水杯】对象的【方法】：【告诉魔法水杯并返回目前使用魔法水杯的人】，这一次不再传递实参给形式参数。
str第二次访问当前水杯拥有者=一只魔法水杯.告诉魔法水杯并返回目前使用魔法水杯的人()
print('str第二次访问当前水杯拥有者=',str第二次访问当前水杯拥有者)
运行结果：
str创造者= 我的创造者是：孤荷凌寒
str水杯的容量= 100毫升
str水杯当前拥有者= 张三
str第二次访问当前水杯拥有者= 张三


四、	为类指定初始化方法
类的初始化方法，即是在【实例化】一个【类】时可以定义让【类】完成哪些操作的方法。
类内部的初始化方法函数的函数 名称 是固定的使用
__init__
这个名称。
在正常情况下__init__这个方法，在类实例化后，是不能通过【具体对象】加点语法直接调用的。
而是在【实例化】类时，映射为调用此初始化方法。
测试：
class 魔法水杯类(object): 
    颜色='红色' #这是魔法水杯类的默认颜色
    材质='魔法玻璃'
    透明度='半透明'
    容量='100毫升' #这是魔法水杯类的默认容量
    当前使用水杯的人='没有' #这是魔法水杯类的默认使用者
  
    #下面定义【类】的初始化方法函数
    def __init__(self,指定水杯颜色,指定水杯容量,当前使用水杯的人='没有'):
        #此初始化方法函数，除了默认的self形参外，定义了三个形参，其中最后一个形参是可选形参。
        self.颜色=指定水杯颜色
        self.容量=指定水杯容量
        if 当前使用水杯的人!='没有':
            self.当前使用水杯的人=当前使用水杯的人
 

    def 告诉访问者魔法水杯的创造者(self): 
        return '我的创造者是：孤荷凌寒'
    def 魔法水杯的容量最大值(self):
        return self.容量 
    def 告诉魔法水杯并返回目前使用魔法水杯的人(self,当前使用水杯的人='没有'): 
        if 当前使用水杯的人!='没有':
            self.当前使用水杯的人=当前使用水杯的人
        return self.当前使用水杯的人

一只魔法水杯=魔法水杯类('蓝色','300毫升','李四') #因为【魔法水杯类】有定义了三个初始化的形式参数，所以这儿在【实例化】类时，要传递初始化实参。
print('一只魔法水杯.颜色=',一只魔法水杯.颜色) 
print('一只魔法水杯.材质=',一只魔法水杯.材质)

str创造者=一只魔法水杯.告诉访问者魔法水杯的创造者() 
str水杯的容量=一只魔法水杯.魔法水杯的容量最大值()

print('str创造者=',str创造者)
print('str水杯的容量=',str水杯的容量)

str水杯当前拥有者=一只魔法水杯.告诉魔法水杯并返回目前使用魔法水杯的人()
print('str水杯当前拥有者=',str水杯当前拥有者)

str水杯当前拥有者=一只魔法水杯.告诉魔法水杯并返回目前使用魔法水杯的人('张三')
 #这儿传递了实参，意味着 杯子 的使用者 有改变！！
print('str水杯当前拥有者=',str水杯当前拥有者)
运行结果 ：
一只魔法水杯.颜色= 蓝色
一只魔法水杯.材质= 魔法玻璃
str创造者= 我的创造者是：孤荷凌寒
str水杯的容量= 300毫升
str水杯当前拥有者= 李四
str水杯当前拥有者= 张三  #杯子 的使用者 有改变！！

类的初始化方法函数 可以不定义，如果没有定义类的初始化方法函数，则
类默认调用一个python默认无任何形参的初始化方法函数。
如果 在类的内部代码块中定义了多个初始化方法函数 ，那么按定义的先后顺序，后定义的初始化方法函数将取代先定义的初始化方法函数。

五、	类的公开属性、公开方法与私有属性、私有方法
类的公开属性、公开方法是指将类实例化为具体对象后，访问对象时，可以直接通过点语法访问这些属性和方法。
类的私有属性、私有方法是指将类实例化为具体对象后，访问对象时，一般情况下无法直接通过点语法访问这些属性和方法。
在类内部代码块中区分公开属性、公开方法与私有属性、私有方法的具体代码写法是：
如果类中的一个属性或方法命名时以__两根英文半角下划线开头，那么这个属性或方法就是类的私有属性和方法。其它的命名方式命名的则是公开属性和方法。
测试：
class 魔法水杯类(object): 
    颜色='红色' #这是魔法水杯类的默认颜色
    材质='魔法玻璃'
    透明度='半透明'
    __容量='100毫升' #此属性已经变成类的私有属性了。
    __当前使用水杯的人='没有' #此属性已经变成类的私有属性了。
  
    #下面定义【类】的初始化方法函数
    def __init__(self,指定水杯颜色,指定水杯容量,当前使用水杯的人='没有'):
        #此初始化方法函数，除了默认的self形参外，定义了三个形参，其中最后一个形参是可选形参。
        self.颜色=指定水杯颜色
        self.__容量=指定水杯容量
        if 当前使用水杯的人!='没有':
            self.__当前使用水杯的人=当前使用水杯的人
 

    def 告诉访问者魔法水杯的创造者(self): 
        return '我的创造者是：孤荷凌寒'
    def 魔法水杯的容量最大值(self):
        return self.__容量 
    def 告诉魔法水杯并返回目前使用魔法水杯的人(self,当前使用水杯的人='没有'): 
        if 当前使用水杯的人!='没有':
            self.__当前使用水杯的人=当前使用水杯的人
        return self.__当前使用水杯的人

一只魔法水杯=魔法水杯类('蓝色','300毫升','李四') #因为【魔法水杯类】有定义了三个初始化的形式参数，所以这儿在【实例化】类时，要传递初始化实参。
print('一只魔法水杯.颜色=',一只魔法水杯.颜色) 
print('一只魔法水杯.__容量=',一只魔法水杯.__容量) #这句代码将执行报出错误，因为我们不能访问类中的私有属性【_容量】

str创造者=一只魔法水杯.告诉访问者魔法水杯的创造者() 
str水杯的容量=一只魔法水杯.魔法水杯的容量最大值()

print('str创造者=',str创造者)
print('str水杯的容量=',str水杯的容量)

str水杯当前拥有者=一只魔法水杯.告诉魔法水杯并返回目前使用魔法水杯的人()
print('str水杯当前拥有者=',str水杯当前拥有者)

运行结果：
一只魔法水杯.颜色= 蓝色
Traceback (most recent call last):
  File "c:\Users\pw\Desktop\新建文本文档.py", line 28, in <module>
    print('一只魔法水杯.__容量=',一只魔法水杯.__容量) #这句代码将执行报出错误，因为我们不能访问类中的私有属性【_容量】
AttributeError: '魔法水杯类' object has no attribute '__容量'
str创造者= 我的创造者是：孤荷凌寒
str水杯的容量= 300毫升
str水杯当前拥有者= 李四

欢迎联系我加入倡导终身学习终身成长的社群——
就是要学  社群  www.941xue.com/index.aspx 
 
原文地址：http://www.941xue.com/content.aspx?id=208  
B站视频：https://www.bilibili.com/video/BV1Mt41117gp/  
