迭代也就是循环。
python中的迭代对象有相关的如下几个术语：
A容器 contrainer
	序列/集合/字典等都是容器，我的理解是因为它们都容纳了很多的元素在其中，每个元素都是别的对象，所以称他们为容器非常贴切。
B 可迭代对象 iterable
	大部分容器都是可迭代对象（iterable）
	可迭代对象的意思 是，这个对象本身可以提供有限数量的内部元素供循环语句遍历，因此多数容器都符合这个条件。
C 迭代器 iterater
	可迭代对象可以转换为 迭代器
	使用函数
	迭代器对象=iter(可迭代对象)
	就可将一个可迭代对象转换为一个 迭代器。
 	迭代器 可以直接自动地 逐一将自己变量名所指向 的 内存中的地址 中的元素 一个一个地 根据循环语句的 需要 逐次（每次提交下一个元素 指向内存的起始地址给循环体）
提供。
	部分迭代器 甚至可以将有限的元素集合模拟成无限的数量。循环语句获取时将发现似乎其中的元素永远都取之不尽。这个目前我没有深入研究。
	用print语句尝试输出迭代器对象时，会发现，打印出的它被表示成了内存地址的形式。

D 生成器——一种特殊的迭代器
	generator
	yield
	关于生成器，目前没有深入学习。

一、	判断 一个 对象 是不是 可迭代对象，是不是 迭代器 的方法
需要引用模块（库），然后再使用相关函数 
用到的库是：
collections.py
引用声明：
from collections import Iterable
from collections import Iterator
然后使用全局函数
isinstance来判断类型
1 判断 一个对象 是否是一个可迭代对象
isinstance(要判断的对象,Iterable)
函数返回布尔值。
2 判断 一个对象 是否是一个迭代器
isinstance(要判断的对象,Iterator)
函数返回布尔值。

二、	其它可以自动产生迭代器的常用函数
iter函数可以将 可迭代对象转换成 迭代器
除此之外，以下函数 也可以生成 迭代器：
1 range()函数
range函数用于生成指定的整数序列列表对应的迭代器
格式：
新的迭代器对象=range(起始整数(包含此数),结束整数(不包含此数),步长)
测试：
>>> itrA=range(1,20,2)
>>> print(itrA)
range(1, 20, 2)
>>> for a in itrA:  #itrA作为一个迭代器，可以向循环语句中的变量a逐一提供其中的元素。
	print(a)

1
3
5
7
9
11
13
15
17
19

2 enumerate()函数
此函数会将一个普通序列转换成由元素本身在序列中的index数值与元素对象本身一一对应的一个个元组对组成的复合序列对象对应的 迭代器
格式：
新的迭代器=enumerate(序列对象)
测试：
>>> lstA=list('大家好，我是孤荷凌寒')
>>> itrB=enumerate(lstA)
>>> print(itrB)
#用print语句输出迭代器时，会发现打印出的它被表示成了内存地址的形式。
<enumerate object at 0x000001C940156EA0>
>>> for index,obj in itrB:  #迭代器itrB每次向循环语句提供同一元素的两个对象
	print('当前元素index:',index,'值：',obj)

当前元素index: 0 值： 大
当前元素index: 1 值： 家
当前元素index: 2 值： 好
当前元素index: 3 值： ，
当前元素index: 4 值： 我
当前元素index: 5 值： 是
当前元素index: 6 值： 孤
当前元素index: 7 值： 荷
当前元素index: 8 值： 凌
当前元素index: 9 值： 寒

3 sorted()函数
对序列进行排序。
格式：
sorted(序列对象,key=排序关键字函数,排序方向的布尔值)
排序关键字函数，是我的理解并备注。
此参数是关键字参数，必须以
key=函数名
或
key=适时定义的匿名函数
的方式来进行传递。
而我的理解是，这个函数其实只是指定了以序列中的元素的哪个关键字（或部分）来进行排序，并定义具体的排序规则，可以存在多种复杂的规则。
排序方向的布尔值，只能传递布尔值True或False中的其中一个，如果传入True，表示逆序排序；如果传入False，表示正序排序。
特别注意：
我发现此函数与今天所学的其它函数都不同的地方在于，它并不是 返回了一个迭代器对象，而是返回的真正的序列对象。原序列的内容没有改变。
测试：
lstA=[('john','A',15),('jone','B',12),('dave','B',10)]
print(sorted(lstA,key=lambda x:x[2])) #这儿的排序函数是实时定义的匿名函数，只指明了按列表中元素——是元组对象的index为2的元素的值进行排序。

运行结果：
[('dave', 'B', 10), ('jone', 'B', 12), ('john', 'A', 15)]
从运行结果中可以看出——
此列表，共有三个元素，每个元素都是一个元组；
每个元组都有三个元素，index值分别为0，1，2；
而实时定义的排序关键字函数指明了x:x[2],按元组对象的index为2的元素的大小排序。
于是结果是正确的排好的序，10<12<15
现在我们对排序函数进行修改：
lstA=[('john','A',15),('jone','B',12),('dave','B',10)]
print(sorted(lstA,key=lambda x:x[0])) #这儿的排序函数是实时定义的匿名函数，只指明了按列表中元素——是元组对象的index为0的元素的值进行排序。

运行结果：
[('dave', 'B', 10), ('john', 'A', 15), ('jone', 'B', 12)]

4 reversed() 函数
此函数反转一个序列中元素的先后顺序。
格式：
新的迭代器对象=reversed(序列对象)
测试：
strA='孤荷凌寒参加工作后，每天在工作之外的空闲时间只能看着窗外的群山发呆，小山村没多少人，虽然自己也在农村长大，但孤荷凌寒并不玩牌，也性格内向。'
itrA=reversed(strA)
print(itrA) #直接打印 迭代器，只能显示 内存地址
lstA=list(itrA)  #只能转换成list才能显示，不能直接还原成字符串了
print(lstA)
运算结果：
<reversed object at 0x000001DF1EFE4C88>
['。', '向', '内', '格', '性', '也', '，', '牌', '玩', '不', '并', '寒', '凌', '荷', '孤', '但', '，', '大', '长', '村', '农', '在',
'也', '己', '自', '然', '虽', '，', '人', '少', '多', '没', '村', '山', '小', '，', '呆', '发', '山', '群', '的', '外', '窗', '着', '看', '能', '只', '间', '时', '闲', '空', '的', '外', '之', '作', '工', '在', '天', '每', '，', '后', '作', '工', '加', '参', '寒', '
凌', '荷', '孤']

5 filter() 函数
筛选一个序列，留下 序列中符合筛选条件的元素，返回新的迭代器：
新的迭代器=filter(筛选函数,序列)
筛选函数将有一个参数，对应于序列中的每一个元素。
且筛选函数的返回对象只能是布尔对象即：True  或者 False
在filter函数执行时，序列中的每一个元素都会被作为实参传递进筛选函数中进行运算，当序列中的一个元素传递进筛选函数后，如果筛选函数的运算结果是：True，则此元素会被认为符合筛选条件而通过筛选，被存放入新的迭代器对象中；如果筛选函数运算的结果是False，则此元素会被认为不符合筛选条件，就被忽略掉。
测试：
strA='孤荷凌寒参加工作后，每天在工作之外的空闲时间只能看着窗外的群山发呆，小山村没多少人，虽然自己也在农村长大，但孤荷凌寒并不玩牌，也性格内向。'
def shaixuan(yuansu):
    strKey='孤荷凌寒'
    if yuansu=='，':
        return True
    elif yuansu in strKey:
        return True
    else:
        return False

itrA=filter(shaixuan,strA)
print(itrA)
lstA=list(itrA)
print(lstA)
运算结果 ：
<filter object at 0x000002457AB54C88>
['孤', '荷', '凌', '寒', '，', '，', '，', '，', '孤', '荷', '凌', '寒', '，']

6 map()函数
将指定的一个或多个序列的每个元素都由作为指定的同一个函数的实参，然后由函数进行运算，并返回结果，然后将所有结果组合成一个新的迭代器对象返回。
格式：
map(执行函数名 ，序列 [,序列2] [,序列3] [……])
执行函数名是指要对序列的每个元素进行运算而事先已经定义好的函数的函数名。
此函数要求至少要有一个形式参数，以便序列的每个元素都可以作为实参而传递进入函数体内进行运算。
此函数在对序列的每个元素进行运算后都必须返回一个对象。
map()函数与filter()函数的不同之处在于，map()函数可以一次接受传入多个序列。
传入n个序列则意味着map()函数的第一个形参——执行函数——必须要有n个形式参数，以便接收n个序列的各自的每个元素参与执行函数内部的运算。
测试：
strA='读书是当时孤荷凌寒与外部世界沟通的唯一通道。'
strB='孤荷凌寒利用一切可以利用的休息时间学习。'
strC='当孤荷凌寒知道了世界上还有“电脑”这样的神奇的东西存在之后'
strD='孤荷凌寒准备自己学习英语，为的是有一天能够学习电脑。'
def function(yuansu):
    strKey='孤荷凌寒'
    if yuansu=='，':
        return '逗号'
    elif yuansu in strKey:
        return yuansu
    else:
        return '0'

itrA=map(function,strA)
print(itrA)
lstA=list(itrA)
print(lstA)
运算结果：
<map object at 0x000001D3E0FB4D30>
['0', '0', '0', '0', '0', '孤', '荷', '凌', '寒', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
传入多个序列的测试：
strA='孤荷凌寒读书是当时与外部世界沟通的唯一通道。'
strB='孤荷凌寒利用一切可以利用的休息时间学习。'
strC='当孤荷凌寒知道了世界上还有“电脑”这样的神奇的东西存在之后'
strD='孤荷凌寒准备自己学习英语，为的是有一天能够学习电脑。'
def function(yuansu,ys2,ys3,ys4):
    strKey='孤荷凌寒'
    if ((yuansu in strKey) and (ys2 in strKey) and (ys3 in strKey) and (ys4 in strKey)):
        return '命中'
    else:
        return '0'

itrA=map(function,strA,strB,strC,strD)
print(itrA)
lstA=list(itrA)
print(lstA)
运行结果：
<map object at 0x00000227EFFE7BE0>
['0', '命中', '命中', '命中', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']

7 reduce()
from functools import reduce
newobj=reduce(func,序列[,数值常量][……])
此函数的用法，我的初步理解是：
将传入的序列用函数 func 进行计算
定义的func函数有几个形参就要有几个序列和常量传入
此函数没有完全弄清楚，测试如下：
from functools import reduce
def func(var,var2):
    return var + var2
lstA=[1,2,3,4]
lstB=[4,3,2,1]
intA=reduce(func,lstA,10)
print(intA)
运算结果：
20

欢迎联系我加入倡导终身学习终身成长的社群——
就是要学  社群  www.941xue.com/index.aspx 
 
原文地址：http://www.941xue.com/content.aspx?id=177
B站视频：https://www.bilibili.com/video/BV14t411U79b/
