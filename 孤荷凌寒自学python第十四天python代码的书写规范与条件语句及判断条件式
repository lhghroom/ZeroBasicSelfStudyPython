在我学习过的所有语言中，对VB系的语言比较喜欢，而对C系和J系语言比较不喜欢。
可能有朋友说，C系和J系功能好得多。
那是事实！
而我之所以对C系和J系语言的不喜欢，
其实只是一个小小的原因
那是因为它们在代码的书写规范上要写那个令人打键盘时非常捉急的
{}
而且频繁使用~~~~~~~
写出来的代码倒是没有关系，看上去非常整洁，能够清晰明了地看出代块的起止。
但在敲代码时，因为本人双手可能协调能力比不过大家，敲打{}让我感觉很吃力。
第二个原因是，C系与J系语句结尾的;号~~~~~
现在我看到了python语句书写规范中最吸引我的地方——
python语句块的起止表示非常简便，没有{}，也没有if ……end if之类的界定，也没有语句结束的;
整个是非常满足我口味的语言啊！！！
python的语句块起止的界定只依赖于行首的缩进
这对于已经有良好代码书写习惯的编程老手来说，完全没有问题，就算对于新学编程的新手来说，也是很容易也是必须会掌握的基础，除此之外，python就没有别的复杂的语句规范了。

一、python语句块的界定
具体说，python是怎么用仅仅依靠每行代码行首的缩进来界定语句块的起止的呢？
简单举例说，就是：
如果连续三行代码的行首缩进都是三个空格，那么python就认定这三行代码是同一语句块的。
具体测试例子如下：
strA='孤荷凌寒'
if strA=='孤荷凌寒':
    print('你是孤荷凌寒')
else:
    print(strA)
上面的测试例子中：
strA='孤荷凌寒'
if strA=='孤荷凌寒':
else:
这三行语句的行首缩进是没有缩进，那么，他们是同级别语句，组成一个级别的语句块。
而在
if strA=='孤荷凌寒':
一行语句和
else:
一行语句之间的
print('你是孤荷凌寒')
语句缩进了四个空格，因此它是独立的一个语句块

二、条件语句的基础——布尔变量
布尔型变量(Boolean Variable)是有两种逻辑状态的变量，它只有两种可能的值：
真(True)     假(False)。
是的，布尔变量就是用于表示 逻辑 状态的变量，在逻辑运算中，我们只需要两种状态——真 或者 假。
这是编程语言中非常重要的状态判断基础。整个程序的细节部分处处都要判断表达式的状态是真还是假。
所以这是编程语句的基础。
python中有一个全局函数 bool 可以将其它开始数据类型和变量转换成布尔变量，使其它变量或对象的值变成 True 和 False 中的其中一个。
bool(obj)
此函数不是返回True就是返回False
具体，bool函数是怎么知道一个变量值换成布尔变量值后是True 还是False 的呢？
所有不是0 的数，都是 True
0   None  空格  ‘’   空的对象  都是 False

三、判断一个对象或表达式的状态是True还是False的代码
python的逻辑状态判断语句书写格式上非常灵活，最接近自然语言。
判断语句也叫做判断条件式或判断表达式。
对于数值型的变量或表达式可以按自然语言的写法来写：
0<m<=3
此判断语句表示：m是否大于0并且小于等于3
常用的判断符号（正式称呼为逻辑运算符）是：
== 是否等于
<  是否小于
>  是否大于
<=是否小于等于
>=是否大于等于
!= 是否不等于
如果 要连接 几个判断 语句，则可以使用逻辑连接关键字：
and  连接的两个判断语句要同时为True，整个连接后的判断语句组才为True，否则为False
or   连接的两个判断语句只要有一个为True，整个连接后的判断语句组都为True，否则为False
not  反转结果，为True的被反转为False,为False的被反转为True 这个关键词用在判断语句之前。
测试：
>>> a=3
>>> b=4
>>> c=5
>>> d=6
>>> print(a<b<c)
True
>>> print(a+b>6 and c<d)
True
>>> print(a+b<d and c<d)
False
>>> print(a+b<d or c<d)
True
>>> print(a!=b)
True
>>> print(not a!=b)
False
>>> print(a==b==c)
False
四、条件控制语句
条件控制语句用于通过判断条件式的状态结果来决定程序走向不同的流程块
基本语句格式为：
if 判断条件式1,将返回一个布尔值 ：
	如果上述条件式1返回True
	就执行此部分代码块。
elif 判断条件式2，将返回一个布尔值 ：
	如果上述条件式2返回True
	就执行此部分代码块。
elif ……
	可以有多个elif……
else:
	如果上面的条件式1，条件式2，至条件式n都返回False，
	那么就会执行此部分代码块。

五、判断条件式是怎么得出布尔值并返回的。
	1 数值比较
	这个比较好理解，比数值大小即可。
	2 字符串比较
		通过逻辑运算符比较时，字符中的判断标准是：
		如果 只是比较 == （是否相等），那么字符串完全一样则相等。
		如果 是比较大小，则按字符的编码进行大小比较。
	3 序列的比较
		序列的比较的运算逻辑相对复杂
		测试如下：
>>> lstA=[1,2]
>>> lstB=[2,1]
>>> lstC=[2,[1,2]]
>>> lstD=[2,[1,3]]
>>> print(lstA<lstB)
True
>>> print(lstB<lstA)
False
>>> print([1,2]==lstA)
True
>>> print(lstC==lstD)
False
>>> print(lstC>lstD)
False
>>> print(lstC<lstD)
True

六、错误断言
错误断言可以理解为一种特殊的条件控制语句，当然它也是错误陷阱的一种。
格式如下：
assert 判断条件式 ，如果判断条件式返回False那么要返回的字符串
注意assert后面没有括号，说明它并不是函数
说明assert是一种特殊的条件控制语句，如果它后面的【判断条件式】返回False，就返回第二个参数中预设的字符串，而不再继续执行它所在代码块后面的语句了。
只有当assert后面的【判断条件式】返回True，才会继续 执行它所在代码块后面的语句。
这些特征都说明assert不是一个函数，而是一个条件控制语句。
同时也起到了防止错误发生的错误陷阱的作用。
测试：
strA='孤荷凌寒'
assert strA=='我爱祖国','已经发现判断条件为False的情况，认定为参数错误，后面的操作就不会执行了。'
if strA=='孤荷凌寒':
    print('你是孤荷凌寒')
else:
    print(strA)
运行结果 ：
assert strA=='我爱祖国','已经发现判断条件为False的情况，认定为参数错误，后面的操作就不会执行了。'
AssertionError: 已经发现判断条件为False的情况，认定为参数错误，后面的操作就不会执行了。
运行结果说明，程序抛出错误，此错误陷阱成功捕获了陷阱，而且此句代码后面的语句也没有再执行了。
进一步修改一下程序，再作测试：
strA='孤荷凌寒'
assert strA=='孤荷凌寒','已经发现判断条件为False的情况，认定为参数错误，后面的操作就不会执行了。'
if strA=='孤荷凌寒':
    print('你是孤荷凌寒')
else:
    print(strA)
运行结果：
你是孤荷凌寒
这一次没有抛出错误提示
而且执行了此句代码后的语句块。

欢迎联系我加入倡导终身学习终身成长的社群——
就是要学  社群  www.941xue.com/index.aspx 
 
原文地址：http://www.941xue.com/content.aspx?id=168
B站视频：https://www.bilibili.com/video/BV1xt411U7p7/

